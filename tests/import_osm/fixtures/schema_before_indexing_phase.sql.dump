--
-- PostgreSQL database dump
--

-- Dumped from database version 9.6.2
-- Dumped by pg_dump version 9.6.2

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET row_security = off;

SET search_path = public, pg_catalog;

DROP INDEX public.osm_relation_osm_id_idx;
DROP INDEX public.osm_relation_geom;
DROP INDEX public.osm_polygon_tmp_osm_id_idx;
DROP INDEX public.osm_polygon_tmp_geom;
DROP INDEX public.osm_point_tmp_osm_id_idx;
DROP INDEX public.osm_point_tmp_geom;
DROP INDEX public.osm_linestring_tmp_osm_id_idx;
DROP INDEX public.osm_linestring_tmp_geom;
DROP INDEX public.idx_wikipedia_article_language_title;
DROP INDEX public.idx_osm_polygon_partition_rank;
DROP INDEX public.idx_osm_polygon_id;
DROP INDEX public.idx_osm_polgyon_geom;
DROP INDEX public.idx_osm_point_osm_id;
DROP INDEX public.idx_osm_point_geom;
DROP INDEX public.idx_osm_linestring_merged_false;
DROP INDEX public.idx_osm_linestring_id;
DROP INDEX public.idx_osm_linestring_geom;
DROP INDEX public.idx_osm_id;
DROP INDEX public.idx_country_osm_grid_geometry;
DROP INDEX public.idx_country_name_partition;
DROP INDEX public.idx_country_name_country_code;
ALTER TABLE ONLY public.wikipedia_article DROP CONSTRAINT pagelinks_pkey;
ALTER TABLE ONLY public.osm_relation DROP CONSTRAINT osm_relation_pkey;
ALTER TABLE ONLY public.osm_polygon_tmp DROP CONSTRAINT osm_polygon_tmp_pkey;
ALTER TABLE ONLY public.osm_polygon DROP CONSTRAINT osm_polygon_pkey;
ALTER TABLE ONLY public.osm_point_tmp DROP CONSTRAINT osm_point_tmp_pkey;
ALTER TABLE ONLY public.osm_point DROP CONSTRAINT osm_point_pkey;
ALTER TABLE ONLY public.osm_merged_multi_linestring DROP CONSTRAINT osm_merged_multi_linestring_pkey;
ALTER TABLE ONLY public.osm_linestring_tmp DROP CONSTRAINT osm_linestring_tmp_pkey;
ALTER TABLE ONLY public.osm_linestring DROP CONSTRAINT osm_linestring_pkey;
ALTER TABLE public.osm_relation ALTER COLUMN id DROP DEFAULT;
ALTER TABLE public.osm_polygon_tmp ALTER COLUMN id DROP DEFAULT;
ALTER TABLE public.osm_point_tmp ALTER COLUMN id DROP DEFAULT;
ALTER TABLE public.osm_linestring_tmp ALTER COLUMN id DROP DEFAULT;
DROP TABLE public.wikipedia_article;
DROP SEQUENCE public.osm_relation_id_seq;
DROP TABLE public.osm_relation;
DROP SEQUENCE public.osm_polygon_tmp_id_seq;
DROP TABLE public.osm_polygon_tmp;
DROP TABLE public.osm_polygon;
DROP SEQUENCE public.osm_point_tmp_id_seq;
DROP TABLE public.osm_point_tmp;
DROP TABLE public.osm_point;
DROP TABLE public.osm_merged_multi_linestring;
DROP SEQUENCE public.osm_linestring_tmp_id_seq;
DROP TABLE public.osm_linestring_tmp;
DROP TABLE public.osm_linestring;
DROP TABLE public.country_osm_grid;
DROP TABLE public.country_name;
DROP FUNCTION public.road_class(type text);
DROP FUNCTION public.rank_place(type text, osmid bigint);
DROP FUNCTION public.rank_address(type text);
DROP FUNCTION public.gettypeforrelations(linked_osm_id bigint, type_value text, rank_search integer);
DROP FUNCTION public.getparentinfo(name_value text, id_value bigint, from_rank integer, delimiter character varying);
DROP FUNCTION public.getosmidwithid(member_id bigint);
DROP FUNCTION public.getnameforrelations(linked_osm_id bigint, type text);
DROP FUNCTION public.getlanguagename(default_lang text, fr text, en text, de text, es text, ru text, zh text);
DROP FUNCTION public.getimportance(rank_search integer, wikipedia character varying, country_code character varying);
DROP FUNCTION public.getalternativesnames(default_lang text, fr text, en text, de text, es text, ru text, zh text, name text, delimiter character varying);
DROP FUNCTION public.get_partition(in_country_code character varying);
DROP FUNCTION public.get_osm_type_polygon(osm_id bigint);
DROP FUNCTION public.get_country_language_code(search_country_code character varying);
DROP FUNCTION public.get_country_code(place geometry);
DROP FUNCTION public.findroadswithingeometry(id_value bigint, partition_value integer, geometry_value geometry);
DROP FUNCTION public.determineroadhierarchyforeachcountry();
DROP FUNCTION public.determinerankpartitioncode(type character varying, geom geometry, osm_id bigint, country_code character varying);
DROP FUNCTION public.determinepartitionfromimporteddata(geom geometry);
DROP FUNCTION public.determineparentplace(id_value bigint, partition_value integer, rank_search_value integer, geometry_value geometry);
DROP FUNCTION public.determinecountrycodeandpartition();
DROP FUNCTION public.countryname(partition_id integer);
DROP FUNCTION public.city_class(type text);
DROP FUNCTION public.array_distinct(anyarray);
DROP TYPE public.rankpartitioncode;
DROP TYPE public.parentinfo;
DROP EXTENSION postgis_topology;
DROP EXTENSION postgis_tiger_geocoder;
DROP EXTENSION postgis;
DROP EXTENSION hstore;
DROP EXTENSION fuzzystrmatch;
DROP EXTENSION plpgsql;
DROP SCHEMA topology;
DROP SCHEMA tiger_data;
DROP SCHEMA tiger;
DROP SCHEMA public;
--
-- Name: public; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA public;


--
-- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON SCHEMA public IS 'standard public schema';


--
-- Name: tiger; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA tiger;


--
-- Name: tiger_data; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA tiger_data;


--
-- Name: topology; Type: SCHEMA; Schema: -; Owner: -
--

CREATE SCHEMA topology;


--
-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;


--
-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';


--
-- Name: fuzzystrmatch; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS fuzzystrmatch WITH SCHEMA public;


--
-- Name: EXTENSION fuzzystrmatch; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION fuzzystrmatch IS 'determine similarities and distance between strings';


--
-- Name: hstore; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;


--
-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';


--
-- Name: postgis; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA public;


--
-- Name: EXTENSION postgis; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION postgis IS 'PostGIS geometry, geography, and raster spatial types and functions';


--
-- Name: postgis_tiger_geocoder; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgis_tiger_geocoder WITH SCHEMA tiger;


--
-- Name: EXTENSION postgis_tiger_geocoder; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION postgis_tiger_geocoder IS 'PostGIS tiger geocoder and reverse geocoder';


--
-- Name: postgis_topology; Type: EXTENSION; Schema: -; Owner: -
--

CREATE EXTENSION IF NOT EXISTS postgis_topology WITH SCHEMA topology;


--
-- Name: EXTENSION postgis_topology; Type: COMMENT; Schema: -; Owner: -
--

COMMENT ON EXTENSION postgis_topology IS 'PostGIS topology spatial types and functions';


SET search_path = public, pg_catalog;

--
-- Name: parentinfo; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE parentinfo AS (
	state text,
	county text,
	city text,
	displayname text
);


--
-- Name: rankpartitioncode; Type: TYPE; Schema: public; Owner: -
--

CREATE TYPE rankpartitioncode AS (
	rank_search integer,
	partition integer,
	calculated_country_code character varying(2)
);


--
-- Name: array_distinct(anyarray); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION array_distinct(anyarray) RETURNS anyarray
    LANGUAGE sql
    AS $_$
  SELECT ARRAY(SELECT DISTINCT unnest($1))
$_$;


--
-- Name: city_class(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION city_class(type text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  RETURN CASE
    WHEN type IN ('administrative', 'postal_code') THEN 'boundary'
    WHEN type IN ('city','borough','suburb','quarter','neighbourhood','town','village','hamlet') THEN 'place'
    WHEN type IN ('residential') THEN 'landuse'
  END;
END;
$$;


--
-- Name: countryname(integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION countryname(partition_id integer) RETURNS text
    LANGUAGE sql
    AS $$
  SELECT COALESCE(name -> 'name:en',name -> 'name',name -> 'name:fr',name -> 'name:de',name -> 'name:es',name -> 'name:ru',name -> 'name:zh') FROM country_name WHERE partition = partition_id;
$$;


--
-- Name: determinecountrycodeandpartition(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION determinecountrycodeandpartition() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  place_centroid GEOMETRY;
BEGIN

  	place_centroid := ST_PointOnSurface(NEW.geometry);

    -- recalculate country and partition
    IF NEW.rank_search = 4 THEN
      -- for countries, believe the mapped country code,
      -- so that we remain in the right partition if the boundaries
      -- suddenly expand.
      NEW.partition := get_partition(lower(NEW.country_code));
      IF NEW.partition = 0 THEN
        NEW.calculated_country_code := lower(get_country_code(place_centroid));
        NEW.partition := get_partition(NEW.calculated_country_code);
      ELSE
        NEW.calculated_country_code := lower(NEW.country_code);
      END IF;
    ELSE
      IF NEW.rank_search > 4 THEN
        NEW.calculated_country_code := lower(get_country_code(place_centroid));
      	NEW.partition := get_partition(NEW.calculated_country_code);
      END IF;
    END IF;
    RETURN NEW;
END;
$$;


--
-- Name: determineparentplace(bigint, integer, integer, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION determineparentplace(id_value bigint, partition_value integer, rank_search_value integer, geometry_value geometry) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  retVal BIGINT;
BEGIN
  FOR current_rank  IN REVERSE rank_search_value..1 LOOP
     SELECT id FROM osm_polygon WHERE partition=partition_value AND rank_search = current_rank AND NOT id=id_value AND ST_Contains(geometry, geometry_value) AND NOT ST_Equals(geometry, geometry_value) INTO retVal;
     IF retVal IS NOT NULL THEN
      return retVal;
    END IF;
  END LOOP;
RETURN retVal;
END;
$$;


--
-- Name: determinepartitionfromimporteddata(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION determinepartitionfromimporteddata(geom geometry) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  result INTEGER;
BEGIN
  SELECT partition, calculated_country_code from osm_polygon where ST_Within(ST_PointOnSurface(geom), geometry) AND rank_search = 4 AND NOT partition = 0 INTO result;
    RETURN result;
END;
$$;


--
-- Name: determinerankpartitioncode(character varying, geometry, bigint, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION determinerankpartitioncode(type character varying, geom geometry, osm_id bigint, country_code character varying) RETURNS rankpartitioncode
    LANGUAGE plpgsql
    AS $$
DECLARE
  place_centroid GEOMETRY;
  result rankPartitionCode;
BEGIN
    --RAISE NOTICE 'determine rank with type % and osm_id %', type, osm_id;
    place_centroid := ST_PointOnSurface(geom);
    IF (osm_id IS NULL) THEN
    result.rank_search := rank_address(type);
  ELSE
    result.rank_search := rank_place(type, osm_id);
  END IF;
    -- recalculate country and partition
    IF result.rank_search = 4 THEN
      -- for countries, believe the mapped country code,
      -- so that we remain in the right partition if the boundaries
      -- suddenly expand.
      result.partition := get_partition(lower(country_code));
      IF result.partition = 0 THEN
        result.calculated_country_code := lower(get_country_code(place_centroid));
        result.partition := get_partition(result.calculated_country_code);
      ELSE
        result.calculated_country_code := lower(country_code);
      END IF;
    ELSE
      IF result.rank_search > 4 THEN
        result.calculated_country_code := lower(get_country_code(place_centroid));
        result.partition := get_partition(result.calculated_country_code);
      END IF;
    END IF;
    RETURN result;
END;
$$;


--
-- Name: determineroadhierarchyforeachcountry(); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION determineroadhierarchyforeachcountry() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  retVal BIGINT;
BEGIN
  FOR current_partition  IN 1..255 LOOP
    FOR current_rank  IN REVERSE 22..4 LOOP
       PERFORM findRoadsWithinGeometry(id, current_partition, geometry) FROM osm_polygon WHERE partition = current_partition AND rank_search = current_rank;
    END LOOP;
  END LOOP;
END;
$$;


--
-- Name: findroadswithingeometry(bigint, integer, geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION findroadswithingeometry(id_value bigint, partition_value integer, geometry_value geometry) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
	UPDATE osm_linestring SET parent_id = id_value WHERE parent_id IS NULL AND ST_Contains(geometry_value,geometry);
END;
$$;


--
-- Name: get_country_code(geometry); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_country_code(place geometry) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  place_centre GEOMETRY;
  nearcountry RECORD;
BEGIN
  place_centre := ST_PointOnSurface(place);

  FOR nearcountry IN select country_code from country_osm_grid where st_covers(geometry, place_centre) order by area asc limit 1
  LOOP
    RETURN nearcountry.country_code;
  END LOOP;

  FOR nearcountry IN select country_code from country_osm_grid where st_dwithin(geometry, place_centre, 0.5) order by st_distance(geometry, place_centre) asc, area asc limit 1
  LOOP
    RETURN nearcountry.country_code;
  END LOOP;

  RETURN NULL;
END;
$$;


--
-- Name: get_country_language_code(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_country_language_code(search_country_code character varying) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  nearcountry RECORD;
BEGIN
  FOR nearcountry IN select distinct country_default_language_code from country_name where country_code = search_country_code limit 1
  LOOP
    RETURN lower(nearcountry.country_default_language_code);
  END LOOP;
  RETURN NULL;
END;
$$;


--
-- Name: get_osm_type_polygon(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_osm_type_polygon(osm_id bigint) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  IF osm_id > 0 THEN
    RETURN 'way';
  ELSE
    RETURN 'relation';
  END IF;  
END;
$$;


--
-- Name: get_partition(character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION get_partition(in_country_code character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  nearcountry RECORD;
BEGIN
  FOR nearcountry IN select partition from country_name where country_code = in_country_code
  LOOP
    RETURN nearcountry.partition;
  END LOOP;
  RETURN 0;
END;
$$;


--
-- Name: getalternativesnames(text, text, text, text, text, text, text, text, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getalternativesnames(default_lang text, fr text, en text, de text, es text, ru text, zh text, name text, delimiter character varying) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  alternativeNames TEXT[];
BEGIN
  alternativeNames := array_distinct(ARRAY[default_lang, en, fr, de, es, ru, zh]);
  alternativeNames := array_remove(alternativeNames, '');
  alternativeNames := array_remove(alternativeNames, name);
RETURN array_to_string(alternativeNames,delimiter);
END;
$$;


--
-- Name: getimportance(integer, character varying, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getimportance(rank_search integer, wikipedia character varying, country_code character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
  langs TEXT[];
  i INT;
  wiki_article_title TEXT;
  wiki_article_language TEXT;
  result double precision;
BEGIN

  wiki_article_title := replace(split_part(wikipedia, ':', 2),' ','_');
  wiki_article_language := split_part(wikipedia, ':', 1);

  SELECT importance FROM wikipedia_article WHERE language = wiki_article_language AND title = wiki_article_title ORDER BY importance DESC LIMIT 1 INTO result;
  IF result IS NOT NULL THEN
    return result;
  END IF;

  langs := ARRAY['english','country','ar','bg','ca','cs','da','de','en','es','eo','eu','fa','fr','ko','hi','hr','id','it','he','lt','hu','ms','nl','ja','no','pl','pt','kk','ro','ru','sk','sl','sr','fi','sv','tr','uk','vi','vo','war','zh'];
  i := 1;

  WHILE langs[i] IS NOT NULL LOOP

  -- try default language for this country, English and then every other language for possible match
    wiki_article_language := CASE WHEN langs[i] = 'english' THEN 'en' WHEN langs[i] = 'country' THEN get_country_language_code(country_code) ELSE langs[i] END;

  SELECT importance FROM wikipedia_article WHERE language = wiki_article_language AND title = wiki_article_title ORDER BY importance DESC LIMIT 1 INTO result;
    IF result IS NOT NULL THEN
      return result;
    END IF;

      IF result IS NOT NULL THEN
        return result;
      END IF;
    i := i + 1;
  END LOOP;
  -- return default calculated value if no match found  
    IF rank_search IS NOT NULL THEN
      return 0.75-(rank_search::double precision/40);
    END IF;
  RETURN NULL;
END;
$$;


--
-- Name: getlanguagename(text, text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getlanguagename(default_lang text, fr text, en text, de text, es text, ru text, zh text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  RETURN CASE
    WHEN en NOT IN ('') THEN en
    WHEN default_lang NOT IN ('') THEN default_lang
    WHEN fr NOT IN ('') THEN fr
    WHEN de NOT IN ('') THEN de
    WHEN es NOT IN ('') THEN es
    WHEN ru NOT IN ('') THEN ru
    WHEN zh NOT IN ('') THEN zh
    ELSE ''
  END;
END;
$$;


--
-- Name: getnameforrelations(bigint, text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getnameforrelations(linked_osm_id bigint, type text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  retVal TEXT;
BEGIN
IF type = 'city' THEN
  SELECT getLanguageName(name, name_fr, name_en, name_de, name_es, name_ru, name_zh) FROM osm_point WHERE osm_id = linked_osm_id INTO retVal;
  ELSE
  retVal = '';
  END IF;
  return retVal;
END;
$$;


--
-- Name: getosmidwithid(bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getosmidwithid(member_id bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  result BIGINT;
BEGIN
  SELECT osm_id FROM osm_linestring WHERE id=member_id  INTO result;
    RETURN result;
END;
$$;


--
-- Name: getparentinfo(text, bigint, integer, character varying); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION getparentinfo(name_value text, id_value bigint, from_rank integer, delimiter character varying) RETURNS parentinfo
    LANGUAGE plpgsql
    AS $$
DECLARE
  retVal parentInfo;
  current_rank INTEGER;
  current_id BIGINT;
  currentName TEXT;
BEGIN
  current_rank := from_rank;
  retVal.displayName := name_value;
  current_id := id_value;
  
  IF current_rank = 16 THEN  
    retVal.city := retVal.displayName;
  ELSE
    retVal.city := '';
  END IF;
  IF current_rank = 12 THEN  
    retVal.county := retVal.displayName;
  ELSE
    retVal.county := '';
  END IF;
  IF current_rank = 8 THEN  
    retVal.state := retVal.displayName; 
  ELSE
    retVal.state := ''; 
  END IF;

  --RAISE NOTICE 'finding parent for % with rank %', name_value, from_rank;
  
  WHILE current_rank >= 8 LOOP
    SELECT getLanguageName(name, name_fr, name_en, name_de, name_es, name_ru, name_zh), rank_search, parent_id FROM osm_polygon  WHERE id = current_id INTO currentName, current_rank, current_id;
    IF currentName IS NOT NULL THEN
      retVal.displayName := retVal.displayName || delimiter || ' ' || currentName;
    END IF;

    IF current_rank = 16 THEN  
      retVal.city := currentName;
    END IF;
    IF current_rank = 12 THEN  
      retVal.county := currentName;
    END IF;
    IF current_rank = 8 THEN  
      retVal.state := currentName;  
    END IF;
  END LOOP;
RETURN retVal;
END;
$$;


--
-- Name: gettypeforrelations(bigint, text, integer); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION gettypeforrelations(linked_osm_id bigint, type_value text, rank_search integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
  retVal TEXT;
BEGIN
IF linked_osm_id IS NOT NULL AND type_value = 'administrative' AND (rank_search = 16 OR rank_search = 12) THEN
  SELECT type FROM osm_point WHERE osm_id = linked_osm_id INTO retVal;
  IF retVal = 'city' THEN
  RETURN retVal;
  ELSE
  RETURN type_value;
  END IF;
ELSE
  return type_value;
 END IF;
END;
$$;


--
-- Name: rank_address(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rank_address(type text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	RETURN CASE
		WHEN type IN ('service','cycleway','path','footway','steps','bridleway','motorway_link','primary_link','trunk_link','secondary_link','tertiary_link') THEN 27
		ELSE 26
	END;
END;
$$;


--
-- Name: rank_place(text, bigint); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION rank_place(type text, osmid bigint) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
	RETURN CASE
		WHEN type IN ('administrative') THEN 2*(SELECT COALESCE(admin_level,15) FROM osm_polygon_tmp o WHERE osm_id = osmID)  
		WHEN type IN ('continent', 'sea') THEN 2
		WHEN type IN ('country') THEN 4
		WHEN type IN ('state') THEN 8
		WHEN type IN ('county') THEN 12
		WHEN type IN ('city') THEN 16
		WHEN type IN ('island') THEN 17
		WHEN type IN ('region') THEN 18 -- dropped from previous value of 10
		WHEN type IN ('town') THEN 18
		WHEN type IN ('village','hamlet','municipality','district','unincorporated_area','borough') THEN 19
		WHEN type IN ('suburb','croft','subdivision','isolated_dwelling','farm','locality','islet','mountain_pass') THEN 20
		WHEN type IN ('neighbourhood', 'residential') THEN 22
		WHEN type IN ('houses') THEN 28
		WHEN type IN ('house','building') THEN 30
		WHEN type IN ('quarter') THEN 30
	END;
END;
$$;


--
-- Name: road_class(text); Type: FUNCTION; Schema: public; Owner: -
--

CREATE FUNCTION road_class(type text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
BEGIN
  RETURN CASE
    WHEN type IN (  'motorway','motorway_link','trunk','trunk_link','primary','primary_link','secondary','secondary_link','tertiary','tertiary_link',
                    'unclassified','residential','road','living_street','raceway','construction','track','service','path','cycleway',
                    'steps','bridleway','footway','corridor','crossing'
                    ) THEN 'highway'
    ELSE 'multiple'
  END;
END;
$$;


SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: country_name; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE country_name (
    country_code character varying(2),
    name hstore,
    country_default_language_code character varying(2),
    partition integer
);


--
-- Name: country_osm_grid; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE country_osm_grid (
    country_code character varying(2),
    area double precision,
    geometry geometry
);


--
-- Name: osm_linestring; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_linestring (
    id integer NOT NULL,
    osm_id bigint,
    type character varying,
    name character varying,
    name_fr character varying,
    name_en character varying,
    name_de character varying,
    name_es character varying,
    name_ru character varying,
    name_zh character varying,
    wikipedia character varying,
    wikidata character varying,
    admin_level integer,
    geometry geometry(LineString,3857),
    rank_search integer,
    partition integer,
    calculated_country_code character varying(2),
    parent_id bigint,
    merged boolean
);


--
-- Name: osm_linestring_tmp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_linestring_tmp (
    id integer NOT NULL,
    osm_id bigint,
    type character varying,
    name character varying,
    name_fr character varying,
    name_en character varying,
    name_de character varying,
    name_es character varying,
    name_ru character varying,
    name_zh character varying,
    wikipedia character varying,
    wikidata character varying,
    admin_level integer,
    geometry geometry(LineString,3857)
);


--
-- Name: osm_linestring_tmp_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE osm_linestring_tmp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: osm_linestring_tmp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE osm_linestring_tmp_id_seq OWNED BY osm_linestring_tmp.id;


--
-- Name: osm_merged_multi_linestring; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_merged_multi_linestring (
    member_ids integer[] NOT NULL,
    type text,
    name character varying,
    name_fr text,
    name_en text,
    name_de text,
    name_es text,
    name_ru text,
    name_zh text,
    wikipedia text,
    wikidata text,
    geometry geometry,
    partition integer,
    calculated_country_code text,
    rank_search integer,
    parent_id bigint
);


--
-- Name: osm_point; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_point (
    id integer NOT NULL,
    osm_id bigint,
    type character varying,
    name character varying,
    name_fr character varying,
    name_en character varying,
    name_de character varying,
    name_es character varying,
    name_ru character varying,
    name_zh character varying,
    wikipedia character varying,
    wikidata character varying,
    admin_level integer,
    geometry geometry(Point,3857),
    rank_search integer,
    partition integer,
    calculated_country_code character varying(2),
    parent_id bigint,
    linked boolean
);


--
-- Name: osm_point_tmp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_point_tmp (
    id integer NOT NULL,
    osm_id bigint,
    type character varying,
    name character varying,
    name_fr character varying,
    name_en character varying,
    name_de character varying,
    name_es character varying,
    name_ru character varying,
    name_zh character varying,
    wikipedia character varying,
    wikidata character varying,
    admin_level integer,
    geometry geometry(Point,3857)
);


--
-- Name: osm_point_tmp_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE osm_point_tmp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: osm_point_tmp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE osm_point_tmp_id_seq OWNED BY osm_point_tmp.id;


--
-- Name: osm_polygon; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_polygon (
    id integer NOT NULL,
    osm_id bigint,
    type character varying,
    country_code character varying,
    name character varying,
    name_fr character varying,
    name_en character varying,
    name_de character varying,
    name_es character varying,
    name_ru character varying,
    name_zh character varying,
    wikipedia character varying,
    wikidata character varying,
    admin_level integer,
    geometry geometry(Geometry,3857),
    rank_search integer,
    partition integer,
    calculated_country_code character varying(2),
    parent_id bigint,
    linked_osm_id bigint
);


--
-- Name: osm_polygon_tmp; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_polygon_tmp (
    id integer NOT NULL,
    osm_id bigint,
    type character varying,
    country_code character varying,
    name character varying,
    name_fr character varying,
    name_en character varying,
    name_de character varying,
    name_es character varying,
    name_ru character varying,
    name_zh character varying,
    wikipedia character varying,
    wikidata character varying,
    admin_level integer,
    geometry geometry(Geometry,3857)
);


--
-- Name: osm_polygon_tmp_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE osm_polygon_tmp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: osm_polygon_tmp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE osm_polygon_tmp_id_seq OWNED BY osm_polygon_tmp.id;


--
-- Name: osm_relation; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE osm_relation (
    id integer NOT NULL,
    osm_id bigint,
    member bigint,
    role character varying,
    type smallint,
    name character varying,
    geometry geometry(Geometry,3857)
);


--
-- Name: osm_relation_id_seq; Type: SEQUENCE; Schema: public; Owner: -
--

CREATE SEQUENCE osm_relation_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


--
-- Name: osm_relation_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: -
--

ALTER SEQUENCE osm_relation_id_seq OWNED BY osm_relation.id;


--
-- Name: wikipedia_article; Type: TABLE; Schema: public; Owner: -
--

CREATE TABLE wikipedia_article (
    language text NOT NULL,
    title text NOT NULL,
    langcount integer,
    othercount integer,
    totalcount integer,
    lat double precision,
    lon double precision,
    importance double precision,
    osm_type character(1),
    osm_id bigint,
    infobox_type text,
    population bigint,
    website text
);


--
-- Name: osm_linestring_tmp id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_linestring_tmp ALTER COLUMN id SET DEFAULT nextval('osm_linestring_tmp_id_seq'::regclass);


--
-- Name: osm_point_tmp id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_point_tmp ALTER COLUMN id SET DEFAULT nextval('osm_point_tmp_id_seq'::regclass);


--
-- Name: osm_polygon_tmp id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_polygon_tmp ALTER COLUMN id SET DEFAULT nextval('osm_polygon_tmp_id_seq'::regclass);


--
-- Name: osm_relation id; Type: DEFAULT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_relation ALTER COLUMN id SET DEFAULT nextval('osm_relation_id_seq'::regclass);


--
-- Name: osm_linestring osm_linestring_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_linestring
    ADD CONSTRAINT osm_linestring_pkey PRIMARY KEY (id);


--
-- Name: osm_linestring_tmp osm_linestring_tmp_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_linestring_tmp
    ADD CONSTRAINT osm_linestring_tmp_pkey PRIMARY KEY (id);


--
-- Name: osm_merged_multi_linestring osm_merged_multi_linestring_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_merged_multi_linestring
    ADD CONSTRAINT osm_merged_multi_linestring_pkey PRIMARY KEY (member_ids);


--
-- Name: osm_point osm_point_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_point
    ADD CONSTRAINT osm_point_pkey PRIMARY KEY (id);


--
-- Name: osm_point_tmp osm_point_tmp_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_point_tmp
    ADD CONSTRAINT osm_point_tmp_pkey PRIMARY KEY (id);


--
-- Name: osm_polygon osm_polygon_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_polygon
    ADD CONSTRAINT osm_polygon_pkey PRIMARY KEY (id);


--
-- Name: osm_polygon_tmp osm_polygon_tmp_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_polygon_tmp
    ADD CONSTRAINT osm_polygon_tmp_pkey PRIMARY KEY (id);


--
-- Name: osm_relation osm_relation_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY osm_relation
    ADD CONSTRAINT osm_relation_pkey PRIMARY KEY (id);


--
-- Name: wikipedia_article pagelinks_pkey; Type: CONSTRAINT; Schema: public; Owner: -
--

ALTER TABLE ONLY wikipedia_article
    ADD CONSTRAINT pagelinks_pkey PRIMARY KEY (language, title);


--
-- Name: idx_country_name_country_code; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_country_name_country_code ON country_name USING btree (country_code);


--
-- Name: idx_country_name_partition; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_country_name_partition ON country_name USING btree (partition);


--
-- Name: idx_country_osm_grid_geometry; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_country_osm_grid_geometry ON country_osm_grid USING gist (geometry);


--
-- Name: idx_osm_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_id ON wikipedia_article USING btree (osm_type, osm_id);


--
-- Name: idx_osm_linestring_geom; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_linestring_geom ON osm_linestring USING gist (geometry);

ALTER TABLE osm_linestring CLUSTER ON idx_osm_linestring_geom;


--
-- Name: idx_osm_linestring_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_linestring_id ON osm_linestring USING btree (id);


--
-- Name: idx_osm_linestring_merged_false; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_linestring_merged_false ON osm_linestring USING btree (merged) WHERE (merged IS FALSE);


--
-- Name: idx_osm_point_geom; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_point_geom ON osm_point USING gist (geometry);

ALTER TABLE osm_point CLUSTER ON idx_osm_point_geom;


--
-- Name: idx_osm_point_osm_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_point_osm_id ON osm_point USING btree (osm_id);


--
-- Name: idx_osm_polgyon_geom; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_polgyon_geom ON osm_polygon USING gist (geometry);

ALTER TABLE osm_polygon CLUSTER ON idx_osm_polgyon_geom;


--
-- Name: idx_osm_polygon_id; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_polygon_id ON osm_polygon USING btree (id);


--
-- Name: idx_osm_polygon_partition_rank; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_osm_polygon_partition_rank ON osm_polygon USING btree (partition, rank_search);


--
-- Name: idx_wikipedia_article_language_title; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX idx_wikipedia_article_language_title ON wikipedia_article USING btree (language, title);


--
-- Name: osm_linestring_tmp_geom; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_linestring_tmp_geom ON osm_linestring_tmp USING gist (geometry);


--
-- Name: osm_linestring_tmp_osm_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_linestring_tmp_osm_id_idx ON osm_linestring_tmp USING btree (osm_id);


--
-- Name: osm_point_tmp_geom; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_point_tmp_geom ON osm_point_tmp USING gist (geometry);


--
-- Name: osm_point_tmp_osm_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_point_tmp_osm_id_idx ON osm_point_tmp USING btree (osm_id);


--
-- Name: osm_polygon_tmp_geom; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_polygon_tmp_geom ON osm_polygon_tmp USING gist (geometry);


--
-- Name: osm_polygon_tmp_osm_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_polygon_tmp_osm_id_idx ON osm_polygon_tmp USING btree (osm_id);


--
-- Name: osm_relation_geom; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_relation_geom ON osm_relation USING gist (geometry);


--
-- Name: osm_relation_osm_id_idx; Type: INDEX; Schema: public; Owner: -
--

CREATE INDEX osm_relation_osm_id_idx ON osm_relation USING btree (osm_id);


--
-- PostgreSQL database dump complete
--

